using System;
using Fumen.Converters;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using MonoGameExtensions;
using StepManiaEditor.AutogenConfig;
using static StepManiaEditor.Editor;
using static StepManiaEditor.Utils;
using static System.Diagnostics.Debug;

namespace StepManiaEditor;

/// <summary>
/// Class for rendering an autogenerated Pattern event.
/// The Pattern is rendered as an IRegion and also as a miscellaneous editor event widget.
/// </summary>
internal sealed class EditorPatternEvent : EditorEvent, IChartRegion,
	Fumen.IObserver<EditorConfig<StepManiaLibrary.PerformedChart.Config>>,
	Fumen.IObserver<EditorConfig<StepManiaLibrary.PerformedChart.PatternConfig>>
{
	public static readonly string EventShortDescription =
		"Patterns are automatically generated sequences of steps.";

	public static readonly string WidgetHelp =
		"Pattern.\n" +
		EventShortDescription;

	/// <summary>
	/// The guid for the EditorPatternConfig that this EditorPatternEvent is using.
	/// </summary>
	public Guid PatternConfigGuid
	{
		get => PatternConfigGuidInternal;
		set
		{
			Assert(EditorChart.CanBeEdited());
			if (!EditorChart.CanBeEdited())
				return;

			if (PatternConfigGuidInternal != value)
			{
				// When switching EditorPatternConfigs we need to observe the new one for
				// changes. We only observe the config if this EditorPatternEvent is added
				// to the chart.
				if (AddedToChart)
					GetPatternConfig().RemoveObserver(this);
				PatternConfigGuidInternal = value;
				if (AddedToChart)
					GetPatternConfig().AddObserver(this);

				// The EditorPatternEvent affects the string used in the misc event widget.
				WidthDirty = true;
			}
		}
	}

	private Guid PatternConfigGuidInternal;

	/// <summary>
	/// The guid for the EditorPerformedChartConfig that this EditorPatternEvent is using.
	/// </summary>
	public Guid PerformedChartConfigGuid
	{
		get => PerformedChartConfigGuidInternal;
		set
		{
			Assert(EditorChart.CanBeEdited());
			if (!EditorChart.CanBeEdited())
				return;

			if (PerformedChartConfigGuidInternal != value)
			{
				// When switching EditorPerformedChartConfigs we need to observe the new one for
				// changes. We only observe the config if this EditorPatternEvent is added
				// to the chart.
				if (AddedToChart)
					GetPerformedChartConfig().RemoveObserver(this);
				PerformedChartConfigGuidInternal = value;
				if (AddedToChart)
					GetPerformedChartConfig().AddObserver(this);

				// The EditorPerformedChartConfig affects the string used in the misc event widget.
				WidthDirty = true;
			}
		}
	}

	private Guid PerformedChartConfigGuidInternal;

	/// <summary>
	/// The length of this EditorPatternEvent in rows.
	/// </summary>
	public int Length
	{
		get => LengthInternal;
		set
		{
			Assert(EditorChart.CanBeEdited());
			if (!EditorChart.CanBeEdited())
				return;

			if (LengthInternal != value)
			{
				var oldEndPosition = GetEndChartPosition();
				LengthInternal = value;

				// Inform the EditorChart of the change so it can update its data structures.
				EditorChart.OnPatternLengthModified(this, oldEndPosition, GetEndChartPosition());
			}
		}
	}

	private int LengthInternal;

	/// <summary>
	/// Random seed for this EditorPatternEvent.
	/// </summary>
	public int RandomSeed
	{
		get => RandomSeedInternal;
		set
		{
			Assert(EditorChart.CanBeEdited());
			if (!EditorChart.CanBeEdited())
				return;

			RandomSeedInternal = value;
		}
	}

	private int RandomSeedInternal;

	/// <summary>
	/// Whether or not the end position of this EditorPatternEvent is inclusive.
	/// </summary>
	public bool EndPositionInclusive
	{
		get => EndPositionInclusiveInternal;
		set
		{
			Assert(EditorChart.CanBeEdited());
			if (!EditorChart.CanBeEdited())
				return;

			EndPositionInclusiveInternal = value;
		}
	}

	private bool EndPositionInclusiveInternal;

	/// <summary>
	/// ChartRow of this EditorPatternEvent.
	/// Exposed via property to allow movement of the event.
	/// </summary>
	public int ChartRow
	{
		get => (int)GetChartPosition();
		set => EditorChart.MoveEvent(this, value);
	}

	#region IChartRegion Implementation

	private double RegionX, RegionY, RegionW, RegionH;

	public double GetRegionX()
	{
		return RegionX;
	}

	public double GetRegionY()
	{
		return RegionY;
	}

	public double GetRegionW()
	{
		return RegionW;
	}

	public double GetRegionH()
	{
		return RegionH;
	}

	public double GetRegionZ()
	{
		return GetChartPosition() + PatternRegionZOffset;
	}

	public void SetRegionX(double x)
	{
		RegionX = x;
	}

	public void SetRegionY(double y)
	{
		RegionY = y;
	}

	public void SetRegionW(double w)
	{
		RegionW = w;
	}

	public void SetRegionH(double h)
	{
		RegionH = h;
	}

	public double GetRegionPosition()
	{
		return GetChartPosition();
	}

	public double GetRegionDuration()
	{
		return Length;
	}

	public bool AreRegionUnitsTime()
	{
		return false;
	}

	public bool IsVisible(SpacingMode mode)
	{
		return true;
	}

	public Color GetRegionColor()
	{
		return IRegion.GetColor(PatternRegionColor, Alpha);
	}

	#endregion IChartRegion Implementation

	/// <remarks>
	/// This lazily updates the width if it is dirty.
	/// This is a bit of hack because in order to determine the width we need to call into
	/// ImGui but that is not a thread-safe operation. If we were to set the width when
	/// loading the chart for example, this could crash. By lazily setting it we avoid this
	/// problem as long as we assume the caller of GetW() happens on the main thread.
	/// </remarks>
	private double WidthInternal;

	public override double W
	{
		get
		{
			if (WidthDirty)
			{
				WidthInternal = ImGuiLayoutUtils.GetMiscEditorEventStringWidth(GetMiscEventText());
				WidthDirty = false;
			}

			return WidthInternal;
		}
		set => WidthInternal = value;
	}

	private bool WidthDirty;

	private bool AddedToChart;

	public EditorPatternEvent(EventConfig config) : base(config)
	{
		PatternConfigGuid = PatternConfigManager.DefaultPatternConfigSixteenthsGuid;
		PerformedChartConfigGuid = PerformedChartConfigManager.DefaultPerformedChartStaminaGuid;
		LengthInternal = SMCommon.RowsPerMeasure;
		RandomSeed = new Random().Next();
		EndPositionInclusive = false;

		ResetTimeBasedOnRow();

		WidthDirty = true;
	}

	public EditorPatternConfig GetPatternConfig()
	{
		return PatternConfigManager.Instance.GetConfig(PatternConfigGuid);
	}

	public EditorPerformedChartConfig GetPerformedChartConfig()
	{
		return PerformedChartConfigManager.Instance.GetConfig(PerformedChartConfigGuid);
	}

	public string GetMiscEventText()
	{
		var patternConfig = GetPatternConfig();
		var performedChartConfig = GetPerformedChartConfig();
		return $"{patternConfig.GetPrettyString()} ({patternConfig.Name} {performedChartConfig.Name})";
	}

	public uint GetMiscEventTextColor()
	{
		var patternConfig = GetPatternConfig();
		return ArrowGraphicManager.GetArrowColorForSubdivision(EditorPatternConfig.GetBeatSubdivision(patternConfig.PatternType));
	}

	public override bool IsMiscEvent()
	{
		return true;
	}

	public override bool IsSelectableWithoutModifiers()
	{
		return false;
	}

	public override bool IsSelectableWithModifiers()
	{
		return false;
	}

	public override double GetEndChartPosition()
	{
		return GetChartPosition() + Length;
	}

	public override double GetEndChartTime()
	{
		var endChartTime = 0.0;
		EditorChart.TryGetTimeFromChartPosition(GetEndChartPosition(), ref endChartTime);
		return endChartTime;
	}

	public override int GetLength()
	{
		return Length;
	}

	/// <summary>
	/// Gets a unique identifier for this event to use for ImGui widgets that draw this event.
	/// </summary>
	/// <returns>Unique identifier for this event to use for ImGui widgets that draw this event.</returns>
	protected override string GetImGuiId()
	{
		return $"PatternEvent{ChartRow}";
	}

	/// <summary>
	/// Called when this event is added to its EditorChart.
	/// An event may be added and removed repeatedly with undoing and redoing actions.
	/// EditorPatternConfig events observe their underlying configs when added to a chart.
	/// </summary>
	public override void OnAddedToChart()
	{
		// When added to a chart we want to observe the configuration objects which are relevant to
		// the misc event width.
		AddedToChart = true;
		GetPerformedChartConfig().AddObserver(this);
		GetPatternConfig().AddObserver(this);
		WidthDirty = true;
		base.OnAddedToChart();
	}

	/// <summary>
	/// Called when this event is removed from its EditorChart.
	/// An event may be added and removed repeatedly with undoing and redoing actions.
	/// EditorPatternConfig events stop observing their underlying configs when removed from a chart.
	/// </summary>
	public override void OnRemovedFromChart()
	{
		// When removed from a chart we want to stop observing the configuration objects.
		AddedToChart = false;
		GetPerformedChartConfig().RemoveObserver(this);
		GetPatternConfig().RemoveObserver(this);
		base.OnRemovedFromChart();
	}

	/// <summary>
	/// Notification handler for the EditorPerformedChartConfig.
	/// </summary>
	public void OnNotify(string eventId, EditorConfig<StepManiaLibrary.PerformedChart.Config> config, object payload)
	{
		switch (eventId)
		{
			// The EditorPerformedChartConfig name affects the misc event text and width.
			case EditorPerformedChartConfig.NotificationNameChanged:
			{
				WidthDirty = true;
				break;
			}
		}
	}

	/// <summary>
	/// Notification handler for the EditorPatternConfig.
	/// </summary>
	public void OnNotify(string eventId, EditorConfig<StepManiaLibrary.PerformedChart.PatternConfig> config, object payload)
	{
		switch (eventId)
		{
			// The EditorPatternConfig name affects the misc event text and width.
			case EditorPatternConfig.NotificationNameChanged:
			{
				WidthDirty = true;
				break;
			}
			// The EditorPatternConfig pattern type affects the misc event text and width.
			case EditorPatternConfig.NotificationPatternTypeChanged:
			{
				WidthDirty = true;
				break;
			}
		}
	}

	public override void Draw(TextureAtlas textureAtlas, SpriteBatch spriteBatch, ArrowGraphicManager arrowGraphicManager)
	{
		ImGuiLayoutUtils.MiscEditorEventPatternWidget(
			GetImGuiId(),
			this,
			(int)X, (int)Y, (int)W,
			UIPatternColorRGBA,
			IsSelected(),
			Alpha,
			WidgetHelp,
			() => { EditorChart.OnPatternEventRequestEdit(this); });
	}
}
